



네이버는 운영체제 물어봤음

# python

python은 인터프리터 언어로 코드를 한줄씩 읽어 내려가며 실행하는 프로그래밍 언어. 속도 측면에서는 컴파일 언어보다 느리지만, 수정이 간단하다는 장점

python은 프로그래머 귀도 반 로섬이 발표했으며 인터프리터식, 객체지향적, 동적 타이핑 대화형 언이다.

> CPython 인터프리터 실행 중에 단점이 있는데 GIL(global interpreter lock)을 사용한다는 것이다. bytecode를 실행할 때에 여러 thread를 사용할 경우, 전체에 lock 을 걸어서 한번에 단 하나의 thread 만이 python object에 접근하도록 제한한 것이다. 하지만 single thread일 때는 문제가 없고 GIL의 단점을 보안하기 위한 방법들이 존재하고 있어서 GIL로 인한 불편함을 느낄 가능성은 거의 없다고 한다.



1. GIL(Global Interpreter Lock)

파이썬은 자원배분을 단순하게 한다. 자원 배분을 한 쓰레드에게 할당하고, 끝날때까지 다른 쓰레드가 접근하게 못하는 것이다.

# JAVA

####  오버로딩과 오버라이딩 차이는?

오버로딩 : 메소드의 이름은 같고, 매개변수를 다르게 함으로써 여러 메소드를 만드는 것

오버라이딩 : 부모클래스로부터 상속받은 메소드를 재정의하는 것. 자식 객체에서 오버라이딩한 메소드는 호출시 오버라이딩한 메소드가 우선시 되어 호출됨 (동일한 리턴타입, 메소드 이름, 매개변수를 가져야함)

# 운영체제

하드웨어를 관리하고, 응용 프로그램과 하드웨어를 사이에서 인터페이스 역할을 하는 시스템 소프트웨어다.  시스템의 자원과 동작을 관리한다. 컴퓨터 하드웨어를 모르더라도 프로그램을 쉽게 만들 수 있도록 지원해주는 소프트웨어 



### 운영체제의 주요 기능

CPU 관리, 메모리 관리, IO장치

프로세스와 스레드의 차이에 대해 말해주세요.

### 프로세스 관리

운영체제에서 작동하는 응용 프로그램을 관리하는 기능이다.

어떤 의미에서는 프로세서(CPU) 관리하는 것이라고 볼 수도 있다. 현재 CPU를 점유해야 할 프로세스를 결정하고, 실제로 CPU를 프로세스에 할당하며, 이 프로세스 간 공유 자원 접근과 통신 등을 관리하게 된다.

### 프로세스와 스레드 차이

* 프로세스는 메모리 상에서 실행중인 프로그램, 자신만의 고유 공간과 자원을 할당받아 사용, 작업의 단위

* 스레드는 프로세스 안에서 실행되는 흐름 단위다, 다른 스레드와 공간과 자원을 공유하면서 사용, 실행의 단위

* 프로세스마다 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소공간을 독립적으로 할당받는다. 스레드는 code, data, heap, stack 중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.
* **프로세스는 자신만의 고유 공간과 자원을 할당받아 사용**하는데 반해, **스레드는 다른 스레드와 공간, 자원을 공유하면서 사용**하는 차이가 존재함

### 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능함

프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함

대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 한다.



### 메모리

메인메모리는 cpu가 직접 접근할 수 있는 장치, 프로세스가 실행되려면 프로그램이 메모리에 있어야 한다.

### 메모리 관리 장치(MMU)

논리 주소를 물리주소로 변환해줌, 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 관리해주는 하드웨어, 

### 가상 메모리

* 메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법

* 메모리 공간이 한정적이기 때문에 더 많은 메모리를 제공하기 위해 가상 주소 라는 개념 등장 

프로세스에서 사용하는 메모리 주소와 실제 물리적 메모리 주소는 다를 수 있음

따라서 메모리 = 실제 + 가상 메모리라고 생각하면 안됨

메모리가 부족해서 가상메모리를 사용하는 건 맞지만, 가상메모리를 쓴다고 실제 메모리처럼 사용하는 것은 아님

실제 메모리 안에 공간이 부족하면, **현재 사용하고 있지 않은 데이터를 빼내어 가상 메모리에 저장해두고, 실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할**이다.

즉, 실제 메모리에 놀고 있는 공간이 없게 계속 일을 시키는 것. 이를 도와주는 것이 '가상 메모리'



### 컨텍스트 스위칭(context switching)?

* CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업을 컨텍스트 스위칭이라 한다. 이러한 컨텍스트 스위칭을 통해 우리는 멀티 프로세싱, 멀티 스레딩 운영이 가능하다.

* 컨텍스트 스위칭은 다음과 같은 상황에서 일어난다.

1. I/O interrupt

2. CPU 사용시간 만료

3. 자식 프로세스 Fork



* 이러한 컨텍스트 스위칭이 일어날 때 다음번 프로세스는 **스케줄러**가 결정하게 된다. 즉, **컨텍스트 스위칭을 하는 주체는 스케줄러**이다.

* 단점: PCB를 저장하고 가져올때는 CPU가 아무런 일도 하지 못하게 된다. 따라서 컨텍스트 스위칭이 너무 잦으면 오버헤드가 발생하여(비용이 높아) 성능이 떨어진다. 

* 스레드 VS 프로세스(In Context Switching)

  이때 스레드가 프로세스보다 빠른 이유도 컨텍스트 스위칭이 한몫한다. 스레드는 컨텍스트 스위칭 될때 text, data, heap 영역은 프로세스 것이기에 자신의 PCB에는 스택 및 간단한 정보만 저장하기에 프로세스 컨텍스트 스위칭 보다 훨씬 바르다.

### PCB(Process Control Block)?

* 운영체제가 프로세스를 제어하기 위해 정보를 저장해두는 곳, 프로세스의 상태 정보를 저장하는 구조체이다.
* 프로세스의 상태 관리와 `문맥교환(context switching)`을 위해 필요하다.
* PCB는 프로세스 생성시 만들어지며 `주기억장치`에 유지된다.

### 주기억장치?

* 주기억장치는 CPU가 직접 접근하여 처리할 수 있는 고속의 기억장치(Memory)로 현재 수행되는 프로그램과 데이터를 저장하고 있습니다. 종류에는 롬(ROM)과 램(RAM)이 있습니다.



### 비동기 / 동기 / 블로킹 / 논블로킹

* 동기/비동기는 **작업을 수행하는 주체**가 두 개 이상이어야 합니다. 이 때 작업의 시간(시작, 종료 등)을 서로 맞춘다면 이를 동기라고 부르고, 서로 작업의 시간이 관계없다면 이를 비동기라고 부릅니다.

* 반면 블로킹/논블로킹은 **작업의 대상**이 2개 이상이어야 합니다. 두 개념이 서로 바라보는 관점이 다르기 때문에 동기/블로킹, 동기/논블로킹, 비동기/블로킹, 비동기/논블로킹의 다양한 조합이 가능합니다.

* 동기의 조건: 두 개 이상의 작업의 시작시간, 종료시간이 같거나 시작과 동시에 종료할 것
* 비동기의 조건: 다른 작업과 시작, 종료 시간을 맞추지 말 것. 시작과 종료를 각자의 페이스대로 유지.
* 블로킹의 조건: 다른 작업을 하는 동안 자신의 작업을 일시정지할 것
* 논블로킹의 조건: 다른 작업의 주체가 작업하는 동안 기다리지 말 것

* 자원이 충분하다면 효율이 가장 좋은 조합은 -> 비동기 + 논블로킹 조합이다 !!
* 보통 우리가 비동기적으로 처리한다는 말은 작업 수행이 논블로킹하다는 의미를 내포한다.