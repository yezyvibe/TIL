# python

* python은 인터프리터 언어로 코드를 한줄씩 읽어 내려가며 실행하는 프로그래밍 언어. 속도 측면에서는 컴파일 언어보다 느리지만, 수정이 간단하다는 장점

* python은 프로그래머 귀도 반 로섬이 발표했으며 인터프리터식, 객체지향적, 동적 타이핑 대화형 언이다.

> CPython 인터프리터 실행 중에 단점이 있는데 GIL(global interpreter lock)을 사용한다는 것이다. bytecode를 실행할 때에 여러 thread를 사용할 경우, 전체에 lock 을 걸어서 한번에 단 하나의 thread 만이 python object에 접근하도록 제한한 것이다. 하지만 single thread일 때는 문제가 없고 GIL의 단점을 보안하기 위한 방법들이 존재하고 있어서 GIL로 인한 불편함을 느낄 가능성은 거의 없다고 한다.



1. GIL(Global Interpreter Lock)

* 파이썬은 자원배분을 단순하게 한다. 자원 배분을 한 쓰레드에게 할당하고, 끝날때까지 다른 쓰레드가 접근하지 못하는 것이다.

# JAVA

####  오버로딩과 오버라이딩 차이는?

* 오버로딩 : 메소드의 이름은 같고, 매개변수를 다르게 함으로써 여러 메소드를 만드는 것

* 오버라이딩 : 부모클래스로부터 상속받은 메소드를 재정의하는 것. 자식 객체에서 오버라이딩한 메소드는 호출시 오버라이딩한 메소드가 우선시 되어 호출됨 (동일한 리턴타입, 메소드 이름, 매개변수를 가져야함)

# 운영체제

* 하드웨어를 관리하고, 응용 프로그램과 하드웨어들 사이에서 인터페이스 역할을 하는 시스템 소프트웨어다.  시스템의 자원과 동작을 관리한다. 컴퓨터 하드웨어를 모르더라도 프로그램을 쉽게 만들 수 있도록 지원해주는 소프트웨어 



### 운영체제의 주요 기능

CPU 관리, 메모리 관리, IO장치

프로세스와 스레드의 차이에 대해 말해주세요.

### 프로세스 관리

운영체제에서 작동하는 응용 프로그램을 관리하는 기능이다.

어떤 의미에서는 프로세서(CPU) 관리하는 것이라고 볼 수도 있다. 현재 CPU를 점유해야 할 프로세스를 결정하고, 실제로 CPU를 프로세스에 할당하며, 이 프로세스 간 공유 자원 접근과 통신 등을 관리하게 된다.

### 프로세스와 스레드 차이

* 프로세스는 메모리 상에서 실행중인 프로그램, 자신만의 고유 공간과 자원을 할당받아 사용, 작업의 단위

* 스레드는 프로세스 안에서 실행되는 흐름 단위다, 다른 스레드와 공간과 자원을 공유하면서 사용, 실행의 단위

* 프로세스마다 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소공간을 독립적으로 할당받는다. 스레드는 code, data, heap, stack 중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.
* **프로세스는 자신만의 고유 공간과 자원을 할당받아 사용**하는데 반해, **스레드는 다른 스레드와 공간, 자원을 공유하면서 사용**하는 차이가 존재함

### 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능함

프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함

대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 한다.



### 메모리

메인메모리는 cpu가 직접 접근할 수 있는 장치, 프로세스가 실행되려면 프로그램이 메모리에 있어야 한다.

### 메모리 관리 장치(MMU)

논리 주소를 물리주소로 변환해줌, 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 관리해주는 하드웨어, 

### 가상 메모리

* 메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법

* 메모리 공간이 한정적이기 때문에 더 많은 메모리를 제공하기 위해 가상 주소 라는 개념 등장 

프로세스에서 사용하는 메모리 주소와 실제 물리적 메모리 주소는 다를 수 있음

따라서 메모리 = 실제 + 가상 메모리라고 생각하면 안됨

메모리가 부족해서 가상메모리를 사용하는 건 맞지만, 가상메모리를 쓴다고 실제 메모리처럼 사용하는 것은 아님

실제 메모리 안에 공간이 부족하면, **현재 사용하고 있지 않은 데이터를 빼내어 가상 메모리에 저장해두고, 실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할**이다.

즉, 실제 메모리에 놀고 있는 공간이 없게 계속 일을 시키는 것. 이를 도와주는 것이 '가상 메모리'



### 컨텍스트 스위칭(context switching)?

* CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업을 컨텍스트 스위칭이라 한다. 이러한 컨텍스트 스위칭을 통해 우리는 멀티 프로세싱, 멀티 스레딩 운영이 가능하다.

* 컨텍스트 스위칭은 다음과 같은 상황에서 일어난다.

1. I/O interrupt

2. CPU 사용시간 만료

3. 자식 프로세스 Fork



* 이러한 컨텍스트 스위칭이 일어날 때 다음번 프로세스는 **스케줄러**가 결정하게 된다. 즉, **컨텍스트 스위칭을 하는 주체는 스케줄러**이다.

* 단점: PCB를 저장하고 가져올때는 CPU가 아무런 일도 하지 못하게 된다. 따라서 컨텍스트 스위칭이 너무 잦으면 오버헤드가 발생하여(비용이 높아) 성능이 떨어진다. 

* 스레드 VS 프로세스(In Context Switching)

  이때 스레드가 프로세스보다 빠른 이유도 컨텍스트 스위칭이 한몫한다. 스레드는 컨텍스트 스위칭 될때 text, data, heap 영역은 프로세스 것이기에 자신의 PCB에는 스택 및 간단한 정보만 저장하기에 프로세스 컨텍스트 스위칭 보다 훨씬 바르다.

### PCB(Process Control Block)?

* 운영체제가 프로세스를 제어하기 위해 정보를 저장해두는 곳, 프로세스의 상태 정보를 저장하는 구조체이다.
* 프로세스의 상태 관리와 `문맥교환(context switching)`을 위해 필요하다.
* PCB는 프로세스 생성시 만들어지며 `주기억장치`에 유지된다.

### 주기억장치?

* 주기억장치는 CPU가 직접 접근하여 처리할 수 있는 고속의 기억장치(Memory)로 현재 수행되는 프로그램과 데이터를 저장하고 있습니다. 종류에는 롬(ROM)과 램(RAM)이 있습니다.



### 💦비동기 / 동기 / 블로킹 / 논블로킹

* 동기/비동기는 **작업을 수행하는 주체**가 두 개 이상이어야 합니다. 이 때 작업의 시간(시작, 종료 등)을 서로 맞춘다면 이를 동기라고 부르고, 서로 작업의 시간이 관계없다면 이를 비동기라고 부릅니다.
* 반면 블로킹/논블로킹은 **작업의 대상**이 2개 이상이어야 합니다. 두 개념이 서로 바라보는 관점이 다르기 때문에 동기/블로킹, 동기/논블로킹, 비동기/블로킹, 비동기/논블로킹의 다양한 조합이 가능합니다.
* 동기의 조건: 두 개 이상의 작업의 시작시간, 종료시간이 같거나 시작과 동시에 종료할 것
* 비동기의 조건: 다른 작업과 시작, 종료 시간을 맞추지 말 것. 시작과 종료를 각자의 페이스대로 유지.
* 블로킹의 조건: 다른 작업을 하는 동안 자신의 작업을 일시정지할 것
* 논블로킹의 조건: 다른 작업의 주체가 작업하는 동안 기다리지 말 것
* 자원이 충분하다면 효율이 가장 좋은 조합은 -> 비동기 + 논블로킹 조합이다 !!
* 보통 우리가 비동기적으로 처리한다는 말은 작업 수행이 논블로킹하다는 의미를 내포한다.
* setimeout과 axios는 비동기 처리



### 동기화

* 프로세스 동기화 : 하나의 자원을 한 시점에 하나의 프로세스만이 접근
* 스레드 동기화 : 하나의 코드 블록 또는 메소드를 한 시점에 하나의 스레드만이 접근, 한 스레드의 특정 작업이 끝나기 전까지 다른 스레드의 방해를 받지 않도록 하는 것이 필요함(데이터 일관성 유지) 그래서 도입된 개념이 임계 영역과 잠금(락, lock)이다.
* 공유 데이터를 사용하는 코드 영역을 임계 영역으로 정해놓고, 공유 데이터(객체)가 가지고 있는 락을 획득한 단 하나의 스레드만이 해당 영역 내의 코드를 수행할 수 있게 한다. 그리고 해당 스레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 락을 반납해야지만 다른 스레드가 반납된 락을 획득하여 임계영역의 코드를 수행할 수 있게 된다.
* 이처럼 한 스레드가 진행 중인 작업을 다른 스레드가 간섭하지 못하게 하는 것이 스레드의 동기화라고 한다.
* 동기화가 되지 않는다면 데이터 일관성이 지켜지지 않는 문제가 발생

### 경쟁 조건 (Race Condition)

* 여러 프로세스가 공유 데이터를 동시에 조작할 때, 실행의 특정 순서에 따라 결과가 달라지는 상황.

  

### 임계영역

동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역을 의미합니다.

* 임계 영역 문제 해결조건

  (1) 상호 배제(Mutual Exclusion)

  \- 한 스레드가 임계 영역에서 실행 중이면 다른 스레드는 접근 불가능(2) 진행(Progress)

  \-임계 영역에서 실행중인 스레드가 없다면, 임계 영역으로 진입하려는 스레드 중 하나는 유한한 시간 내에 진입할 수 있어야 함

  (3) 한정된 대기(Bounded Waiting)

  \- 임계 영역에 대한 진입 요청 후 무한한 시간을 기다리지 않는 것을 보장

### 뮤텍스와 세마포어

* 뮤텍스와 세마포어는 상호배제를 구현해 공유 자원에 접근 시 발생하는 문제점을 해결하는 기법!!!
* 뮤텍스(Mutex)란?: 한 스레드, 프로세스에 의해 소유될 수 있는 **Key**🔑를 기반으로 한 상호배제기법. Key 에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드,프로세스) 만이 공유자원에 접근할 수 있다.
* 세마포어(Semaphore)? : 세마포어는 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성한다. Signaling mechanism. 현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법

* 뮤텍스와 세마포어의 차이 

  -> 동기화 대상 개수 : 뮤텍스는 동기화 대상 하나, 세마포어는 동기화 대상이 하나 이상

  * 세마포어는 공유 자원에 **세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근**할 수 있습니다. 반면에 뮤텍스는 **오직 1개만의 프로세스(또는 쓰레드)만 접근**할 수 있습니다.

  -> 소유권 차이 : 뮤텍스는 소유권을 가지고 있어 공유자원이 접근하고 있는 스레드만이 뮤텍스 해제 가능, 세마포어는 세마포어 객체를 공유하기 때문에 공유하는 자원에 접근하고 있지 않은 스레드도 해제 가능

  * 현재 수행중인 프로세스가 아닌 **다른 프로세스가 세마포어를 해제할 수 있습니다.** 하지만 뮤텍스는 **락(lock)을 획득한 프로세스가 반드시 그 락을 해제**해야 합니다.
  
  

### 데드락

### 쓰레드 동기화에 있어서 두 가지 방법

- Windows에는 다양한 동기화 기법을 제공하는데 크게 두가지로 나뉜다.
  - \1. 유저 모드 동기화 (User Mode Synchronize)
    - 동기화가 진행되는 과정에서 커널의 힘을 빌리지 않는 (커널 코드가 실행되지 않는) 동기화 기법이다.
    - 따라서 동기화를 위해서 커널 모드로의 전환이 불필요해 성능상의 이점이 있다.
    - 그러나 그만큼 기능상의 제한도 있다.
  - \2. 커널 모드 동기화 (Kernel Mode Synchronize)
    - 커널에서 제공하는 동기화 기능을 활용하는 방법이다.
    - 따라서 동기화에 관련된 함수가 호출될 때마다 커널 모드로의 변경이 필요하고, 이는 성능의 저하로 이어지게 된다.
    - 하지만 그만큼 유저 모드 동기화에서 제공하지 못하는 기능을 제공받을 수 있다.
- 따라서 둘 다 장단점이 있다

# 네트워크



### 통신 프로토콜

- 가장 주요한 프로토콜 종류
- 네트워크상 통신회선을 통해서 컴퓨터, 단말기와 같은 시스템 간 내부적으로 통신, 접속하기 위해서 정보, 자료, 메시지 등을 주고 받는 프로토콜이다.
- 여러가지 종류가 있지만 TCP/IP가 대표적이다.

### 프로토콜

- 공통의 데이터 교환 방법및 순서에 대해 정의한 의사소통 약속, 규약 혹은 규칙 체계를 말한다.
- 종류는 여러가지
- 기기간 통신은 교환되는 데이터 형식에 대해 상호 합의를 요구한다.
- 프로토콜은 통신을 위한 물리적, 소프트웨어적 등 여러 가지 조건을 취하여 결정한다.
- 같은 통신 규약을 사용하면 기종과 모델이 달라도, 다른 프로그램을 사용하더라도 컴퓨터 상호 간에 통신할 수 있게 된다.
- 즉, 프로토콜이 맞으면 통신이 가능하지만 이기종 간 정보통신을 하려면 표준 프로토콜을 설정하여 각각 이를 채택하여 통신망을 구축해야 한다.
- 모든 프로토콜은 크게 세 가지 구성 : 구문, 의미, 타이밍(구의타)
- 구문 : 송수신 데이터 포맷 / 의미 : 데이터의 각 항목이 가지는 의미 / 타이밍 : 데이터 송수신 동작방식의 정의

### 프로토콜 계층 구성

- 기본적으로 데이터 전송제어에 관한 계층
- 통신처리에 관한 계층
- 전세계적으로 프로토콜 표준화가 시도됐고, 가장 대표적인 것은 국제표준화기구에서 정한 OSI 7계층 -> 물리, 데이터링크, 네트워크, 트랜스포트, 세션, 프레젠테이션, 응용
- 프로토콜을 통하여 정할 수 있는 것은 -> 접속 및 전달 방식, 통신방식(순서), 주고 받을 자료 형식, 동기화, 오류제어, 흐름제어, 전송속도 등이 있다.

### TCP/IP

- 대표적인 프로토콜

#### 인터넷 프로토콜

- HTTPS
- HTTP

- 쿠키와 세션의 개념
- 왜 쿠키와 세션을 사용하는지
  - 쿠키와 세션은 아래의 HTTP 특징을 해결하기 위해, 클라이언트 인증을 유지하기 위해 사용한다.
  - 예를 들어, 쿠키와 세션을 사용하지 않으면 쇼핑몰에서 옷을 구매하려고 최초 로그인을 했음에도, 페이지를 이동할 때 마다 계속 로그인을 해야합니다.
  - 서버는 클라이언트가 누군지 기억하지 않기 때문이다. 따라서 쿠키와 세션을 통해서 서버는 클라이언트를 기억하고 있는 것이다.
  - 사용자의 접근성이 매우 떨어지는 요인

* 서버와 클라이언트가 통신을 할 때 마다 서버는 클라이언트가 누구인지 인증을 계속해야 합니다. 그 이유는 HTTP 프로토콜이 connectionless, stateless한 특성이 있기 때문입니다.

### HTTP 프로토콜의 특성

- **Connectionless**
- - 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징
- **Stateless**
- - 통신이 끝나면 상태를 유지하지 않는 특징

### 쿠키(Cookie)

* 클라이언트(브라우저) 측에서 관리되는 작은 기록 정보 파일을 의미한다. 쿠키에는 사용자 인증이 유효한 시간을 명시할 수 있으며, 한 번 유효 시간이 정해지면 브라우저를 끄더라도 인증이 유지된다는 특징이 있습니다.

**1) 쿠키 구성 요소**

- 이름
- - 각각의 쿠키를 구별하는 데 사용되는 이름
- 값
- - 쿠키가 갖고 있는 값
- 유효시간
- - 쿠키의 유지시간
- 도메인
- - 쿠키를 전송할 도메인
- 경로
- - 쿠키를 전송할 요청 경로

**2) 쿠키 동작 방식**

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. HTTP 헤더에 쿠키를 포함 시켜 응답
4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
5. 쿠키가 존재하면 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보내서 요청
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 경우, 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

**3) 쿠키 사용 예**

- 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
- 쇼핑몰의 장바구니 기능

### 세션(Session)

* 세션은 쿠키를 기반으로 하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 **서버** 측에서 관리합니다.

* 서버에서는 클라이언트를 구분하기 위해 **세션 ID**를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지합니다. 물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 세션을 끊도록 설정이 가능합니다.

* 사용자에 대한 정보를 서버에 저장하기 때문에 쿠키보다 **보안**에 좋지만, 사용자가 많아질수록 서버 **메모리**를 많이 차지하게 됩니다.

* 즉, 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 됩니다.

**1) 세션의 동작 방식**

1. 클라이언트가 서버에 접속 시 세션 ID를 발급
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장 ( 이 때 쿠키 이름은 JSESSIONID이다. )
3. 클라이언트가 서버에 다시 접속 시 이 쿠키를 이용해서 세션 ID 값을 서버에 전달

**2) 세션의 특징**

- 각 클라이언트에게 고유 ID를 부여
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 보안 면에서 쿠키보다 우수
- 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨

**3) 세션의 사용 예**

로그인과 같이 보안상 중요한 작업을 수행할 때 사용

### 쿠키와 세션의 차이

* 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷합니다. 그 이유는 세션도 결국 쿠키를 사용하기 때문입니다. 가장 큰 차이점은 **사용자의 기록 정보가 저장되는 위치**입니다.쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.

* 또한 **보안** 면에서 세션이 더 우수하며, **요청 속도**는 쿠키가 세션보다 더 빠른데, 그 이유는 세션의 경우 서버에서의 처리가 필요하기 때문

* 세션은 사용자의 수 만큼 서버 메모리를 차지하기 때문에 요즘은 이런 문제들을 보완한 **토큰 기반의 인증방식**을 사용하는 추세

### 💦CORS

* Cross-Origin Resource Sharing, 교차 출처 리소스 공유

* 교차 출처는 곧 ''다른 출처''

* 사실 두 개의 출처가 서로 같다고 판단하는 로직 자체는 굉장히 간단한데, 두 URL의 구성 요소 중 `Scheme`, `Host`, `Port`, 이 3가지만 동일하면 된다.

  `https://evan-moon.github.io:80`라는 출처를 예로 들면 `https://` 이라는 스킴에 `evan-moon.github.io` 호스트를 가지고 `:80`번 포트를 사용하고 있다는 것만 같다면 나머지는 전부 다르더라도 같은 출처로 인정이 된다는 것이다.

* 여기서 중요한 사실 한 가지는 이렇게 출처를 비교하는 로직이 서버에 구현된 스펙이 아니라 브라우저에 구현되어 있는 스펙이라는 것이다.

  만약 우리가 CORS 정책을 위반하는 리소스 요청을 하더라도 해당 서버가 같은 출처에서 보낸 요청만 받겠다는 로직을 가지고 있는 경우가 아니라면 서버는 정상적으로 응답을 하고, 이후 브라우저가 이 응답을 분석해서 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않고 그냥 버리는 순서인 것이다.

* 즉, CORS는 브라우저의 구현 스펙에 포함되는 정책이기 때문에, 브라우저를 통하지 않고 서버 간 통신을 할 때는 이 정책이 적용되지 않는다. 또한 CORS 정책을 위반하는 리소스 요청 때문에 에러가 발생했다고 해도 서버 쪽 로그에는 정상적으로 응답을 했다는 로그만 남기 때문에, CORS가 돌아가는 방식을 정확히 모르면 에러 트레이싱에 난항을 겪을 수도 있다.

* [출처](https://evan-moon.github.io/2020/05/21/about-cors/) 

### 💦REST API

* 클라이언트랑 서버 간에 데이터를 주고 받는 방식
* 리소스의 표현 상태를 나타내고 
* REST는 리소스가 어떻게 표현되는지 / URI는 어떤 리소스인지 / HTTP메소드는 어떤 행위인지를 나타낸다.
* [참고](https://evan-moon.github.io/2020/04/07/about-restful-api/)

### TCP/IP 4계층

* 네트워크에서 통신이 일어나는 과정을 4계층으로 나타낸 것이며, TCP/IP 같은 프로토콜의 모음으로 이뤄져 있습니다.
* 크게 네트워크 인터페이스(이더넷, 무선LAN) / 인터넷 계층(IP) / 트랜스포트 계층(TCP) / 애플리케이션(HTTP) 계층으로 구성돼 있습니다.

### OSI 7계층

* 현업에서는 OSI 7계층 잘 사용하지 X

* 네트워크 통신을 크게 7가지로 계층화하여 표현한 모델입니다. 물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 이뤄져 있다.

### DNS(Domain Name System)

* URI에 있는 도메인을 IP주소로 변환시켜주는 시스템이다.
* Domain Name System으로 숫자로 구성된 네트워크 주소인 IP주소를 사람이 이해하기 쉬운 명칭인 도메인이름으로 상호 매칭시켜주는 시스템이다. 
* 네트워크의 전화번호부 같은 역할
* 왜 사용할까?
* TCP/IP 통신에서는 상대방의 IP주소가 필수적인데, 일반적인 사용자의 편의성을 고려하여 서버에 도메인명을 붙임
* WWW는 호스트 NAVER.COM이 도메인
* 흐름은?
  * 사용자가 URI를 지정하면 DNS서버에 해당 도메인을 보낸 후 변환된 IP주소를 받습니다. 
  * DNS 서버에서는 루트 도메인부터 계층적으로 검색해 나가서 때로는 비효율적이기 때문에 질의한 정보를 캐시에 저장하게 설정하기도 한다.

### TCP/UDP

* TCP는 신뢰성 있는 연결을 보여줌

*  TCP는 IP와 함께 데이터 통신 시 가장 많이 사용되고 있는 핵심 프로토콜입니다.

* UDP는 순서 없고 비신뢰적 통신, 대신 빠르다는 장점, 데이터그램 단위로 처리하는 프로토콜. 데이터그램은 독립적인 관계를 지니는 패킷. 각각의 패킷은 다른 경로로 독립적으로 처리됨

* 둘의 가장 큰 차이는 연결성, 신뢰성의 유무다.

  TCP는 신뢰성 있는 데이터 통신을 보여준다 -> 시퀀스 번호와 ACK 번호를 가지고 있어서 데이터를 순서대로 전송하고, 또  통신 결과가 성공했는지 안했는지 수신확인을 한다. 예를들어 파일 전송.

  TCP와 다르게 UDP는 비연결적, 비신뢰적 데이터 통신을 한다. 대신 속도가 빠르고 네트워크 부하가 적다는 장점이 있다. 예를들어 실시간 서비스(스트리밍)에 자주 사용됨.

### TCP

* 헤더에는 출발지포트, 목적지포트번호, 시퀀스 번호, ACK번호

### MTU(Maximum Transmission Unit)

* TCP/IP 등과 같은 패킷, 프레임 기반의 네트워크에서 전송될 수 있는 최대 크기의 패킷 또는 프레임을 말한다.
* 프로토콜의 최대 전송 단위(maximum transmission unit, MTU)란 해당 레이어가 전송할 수 있는 최대의 크기 바이트이다

### MSS(Maximum Segment Size)

* TCP상에서 전송할 수 있는 사용자 데이터의 최대 크기이다.

### 3 WAY Handshake

* TCP 3 Way Handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.
* TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정

![img](cs.assets/TCP-connection-1.png)

* 이 과정은 TCP 접속을 성공적으로 성립하기 위해서 반드시 필요하다.

* 여기서 SYN은 'synchronize sequence numbers', 그리고 ACK는'acknowledgment' 의 약자이다.

* 과정 : 클라이언트가 서버에 접속 요청하는 SYN 패킷 보낸다. -> 서버는 SYN요청 받고 클라이언트에게 요청 수락하는 ACK와 SNY 패킷 발송 -> 클라이언트는 서버에 ACK를 보내고 연결돼 데이터를 주고 받게 됨

* 3 Way Handshake 방식은 신뢰성 있는 연결로 통신하게 해준다. TCP 연결을 초기화 할 때 사용한다

### 4 Way Handshake

* TCP의 연결을 해제(Connection Termination) 하는 과정
  세션을 종료하기 위해 수행하는 절차

![img](cs.assets/CN.png)

* 과정 :  클라이언트는 서버에게 연결 종료하겠다는 FIN 플래그 전송 -> 서버는 클라이언트에게 확인했다는 ACK를 보낸다, 데이터 모두 보내고 연결 종료됐다는 FIN 플래그도 보낸다 -> 클라이언트는 알겠다며 ACK를 서버에게 보낸다.

### http / https

* HTTP(Hyper Text Tranfer Protocol)는 인터넷에서 웹서버와 사용자 컴퓨터의 웹 브라우저 사이에 문서를 전송하기 위한 통신 규약(프로토콜!)이다. 즉, http는 인터넷에서 하이퍼텍스트를 전송하기 위해 사용되는 통신 규약이다.
* http는 정보를 단순 텍스로 주고 받기 때문에, 네트워크에서 전송 신호를 인터셉트 하는 경우 데이터 유출이 발생할 수 있어 보안에 취약하다는 문제가 있다.
* http의 보안 취약점을 해결하기 위한 프로토콜이 바로 `HTTPS`
* HTTPS(HTTP + Secure Socket) : 기본 골격이나 사용 목적은 데이터를 주고 받는 과정에 보안적인 요소를 추가했다는 것이 가장 큰 차이다. 쉽게 말해서 HTTPS를 통해 서버와 클라이언트 사이의 통신 내용을 암호화하는 것
* 웹 서버에 접속하는 사용자에게 모두 동일한 암호를 제공하는 것이 아니라 사용자 마다 다른 암호를 제공한다.
* HTTPS에는 키가 두 가지를 가지고 통신, 하나는 공개키 나머지 하나는 개인키다. 클라이언트는 공개키를 얻어 데이터를 암호화해서 전송, 서버는 개인키를 이용해 복호화한다. 반대로 서버가 정보 제공시 개인키로 암호화해 정보를 전송하면 공개키가 있는 클라이언트 누구나 정보를 볼 수 있다.
* HTTP 와 달리 HTTPS는 보안 기능이 추가된 만큼 처리 속도면에서 HTTP 보다 느리다. 물론 요즘의 서버 및 네트워크 상태가 우수하기 때문에 HTTP, HTTPS의 차이를 체감하기 거의 어려워 HTTPS를 사용하는 웹사이트가 많다.

* HTTP단점 : 물론 보안이다. 결제 시스템, 회원 가입과 같이 사용자 정보를 웹서버와 주고 받아야 하는 경우라면 HTTP는 정보 유출의 위험성이 생길 수 밖에 없어 이때는 HTTPS를 사용해야 할 것이다.

* 검색 엔진 최적화에서 보안 요소도 상위 노출 검색의 기준 중 하나이기 때문에 HTTP사이트 보다 HTTPS 사이트가 우선 검색될 수 있다. 따라서 HTTPS가 검색 측면에서도 더 효과적

# 데이터베이스

### JOIN

* 2개 이상의 테이블을 연결하여 데이터를 검색하는 방법
* 관계형 데이터베이스에서는 중복 데이터를 피하기 위해서 데이터를 쪼개 여러 테이블로 나눠서 저장합니다. 이렇게 분리되어 저장된 데이터에서 원하는 결과를 다시 도출하기 위해서는 여러 테이블을 조합할 필요가 있습니다. 관계형 데이터베이스에서는 조인(JOIN) 연산자를 사용해 관련 있는 컬럼 기준으로 행을 합쳐주는 연산입니다.

### JOIN 종류

* INNER JOIN : JOIN 조건에서 값이 일치하는 행만 반환

  * 쉽게 말해 교집합, 두 테이블의 중복된 값을 보여준다.
  * SELECT A.NAME, B.AGE FROM EX_TABLE A INNER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP AND A.DEP = B.DEPT
  * 종류
    * 교차 조인 (CROSS JOIN  - CARTESIN JOIN)
    * 동등/동일 조인(EQUI JOIN)
    * 비등가 조인(NON-EQUI JOIN)
    * 자연 조인 (NATURAL JOIN)

* OUTER JOIN : JOIN 조건에서 한쪽 값이 없더라도 행을 반환, 조인 조건을 만족하지 않는 데이터를 처리하기 위한 JOIN으로 INNER JOIN이 두 테이블에 있는 일치하는 값만 가져오는 것에 비해 OUTER JOIN은 어느 한 쪽의 데이터를 모두 가져온다.

  * **LEFT OUTER JOIN** : JOIN 수행 시 왼쪽에 표기된 데이터를 기준으로 OUTER JOIN을 수행한다.
  * **RIGHT OUTER JOIN** : JOIN 수행 시 오른쪽에 표기된 데이터를 기준으로 OUTER JOIN을 수행한다.
  * **FULL OUTER JOIN** : 조인 수행 시 왼쪽, 오른쪽 테이블의 모든 값을 읽어 JOIN을 수행한다. LEFT OUTER JOIN과 RIGHT OUTER JOIN의 결과를 합집합으로 처리한 결과와 동일하다.

* JOIN SQL 구문은 두 가지 표현법이 가능하다. JOIN을 할 때는 WHERE 조건으로 나타낼 수도 있고, JOIN을 구체적으로 명시하고 ON으로 조건을 나타낼 수도 있다.

  * 명시적 표현법 : JOIN을 구체적으로 적음
  * 암묵적 표현법 : JOIN을 직접 명시하지 않고 WHERE 조건절을 써준다

  

### JOIN 방식

* Nested Loop Join
* Hash Join
* Merge Join